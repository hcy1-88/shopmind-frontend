# 图片滑块验证码实现说明

## 实现概述

实现了一个完整的图片滑块验证码系统，用于在用户请求发送短信验证码前进行人机验证。

## 技术流程

### 1. 前端请求验证码图片
- **API**: `POST /api/auth-service/captcha`
- **调用**: `userApi.getCaptcha()`
- **返回数据**:
  ```typescript
  {
    nonceStr: string       // 验证码唯一标识（UUID）
    canvasSrc: string      // 背景图片（base64，带黑色抠图区域）
    blockSrc: string       // 抠图（base64）
    blockY: number         // 抠图的Y坐标
    blockX: number         // 抠图的X坐标（存储在Redis中，用于后端校验）
  }
  ```

### 2. 用户拖动滑块
- 用户水平拖动滑块，前端计算滑动距离 `moveLength`
- 前端限制只能水平移动，不能垂直移动
- 抠图随滑块移动显示在背景图上

### 3. 后端校验
- **API**: `POST /api/auth-service/captcha/verify`
- **调用**: `userApi.verifyCaptcha({ imageKey, imageCode })`
- **请求参数**:
  ```typescript
  {
    imageKey: string    // nonceStr（验证码唯一标识）
    imageCode: string   // moveLength（用户滑动的距离）
  }
  ```
- **校验逻辑**:
  - 后端从Redis中根据 `imageKey` 取出存储的 `blockX`
  - 验证 `|blockX - moveLength| <= 3`（允许3像素误差）
  - Redis中的数据有效期为15分钟

### 4. 验证成功后发送短信
- 验证码校验通过后，前端使用 `nonceStr` 作为 `captchaToken`
- 调用 `userStore.sendSmsCode({ phone, captchaToken })` 发送短信验证码

## 文件修改清单

### 1. 类型定义 - [src/types/index.ts](src/types/index.ts)
```typescript
// 新增验证码响应类型
export interface CaptchaResponse {
  nonceStr: string
  canvasSrc: string
  blockSrc: string
  blockX: number
  blockY: number
  canvasWidth?: number
  canvasHeight?: number
  blockWidth?: number
  blockHeight?: number
  blockRadius?: number
}

// 新增验证码校验请求类型
export interface VerifyCaptchaRequest {
  imageKey: string    // nonceStr
  imageCode: string   // 滑动距离
}
```

### 2. API 层 - [src/api/user-api.ts](src/api/user-api.ts)
```typescript
// 新增两个API方法
getCaptcha: (params?: { canvasWidth?: number; canvasHeight?: number }): Promise<CaptchaResponse>
verifyCaptcha: (data: VerifyCaptchaRequest): Promise<string>
```

### 3. 验证码组件 - [src/components/SliderImageVerify.vue](src/components/SliderImageVerify.vue)
**重构为 Composition API + TypeScript**:
- 使用 `<script setup lang="ts">` 语法
- 导入 `userApi` 进行后端接口调用
- `getCaptcha()` 方法：调用 `userApi.getCaptcha()` 获取验证码图片
- `endEvent()` 方法：调用 `userApi.verifyCaptcha()` 进行后端校验
  - 成功：调用 `verifySuccessEvent()` 并 `emit('success', { nonceStr, value })`
  - 失败：调用 `verifyFailEvent()` 并显示错误信息
- 使用 `defineExpose` 暴露 `refresh` 方法给父组件
- 使用 `onMounted` 和 `onBeforeUnmount` 管理事件监听器生命周期

**组件特性**:
- 仅支持水平拖动（X轴移动）
- 实时显示抠图位置
- 支持图灵测试（防止机器人）
- 时间限制：10秒内完成
- 刷新按钮：点击可重新获取验证码
- 完整的 TypeScript 类型支持

### 4. 登录对话框 - [src/components/LoginDialog.vue](src/components/LoginDialog.vue)
**主要修改**:
- 导入组件：`SliderCaptcha` → `SliderImageVerify`
- 类型引用：`InstanceType<typeof SliderImageVerify>`
- `handleSendCode()`：打开验证码弹窗，调用 `refresh()` 刷新验证码
- `handleCaptchaSuccess()`：
  - 参数类型：`(captchaData: { nonceStr: string; value: number })`
  - 使用 `captchaData.nonceStr` 作为 `captchaToken` 发送短信
- `handleCaptchaFail()`：显示失败提示消息
- 弹窗宽度：`360px` → `380px`（适配验证码图片）


## 用户体验流程

1. 用户在短信登录界面输入手机号
2. 点击"获取验证码"按钮
3. 弹出图片滑块验证码对话框
4. 用户水平拖动滑块，将抠图拼合到背景图的抠取位置
5. 拖动完成后：
   - **成功**：显示"验证成功"提示，关闭验证码弹窗，发送短信验证码，开始60秒倒计时
   - **失败**：显示"验证失败"提示，滑块和抠图复位，可重新尝试
6. 用户收到短信验证码后，输入验证码完成登录/注册

## 后端实现（已完成）

### CaptchaController
- `POST /captcha`：生成验证码图片
- `POST /captcha/verify`：校验验证码

### CaptchaServiceImpl
- `getCaptcha()`：
  - 从两张预设图片中随机选择一张
  - 使用 `CaptchaUtils.cutByTemplate()` 生成抠图和背景图
  - 将 `blockX` 存入Redis（key: nonceStr, TTL: 15分钟）
  - 返回 base64 编码的图片和坐标信息
- `checkImageCode()`：
  - 从Redis中取出 `blockX`
  - 校验 `|blockX - imageCode| <= 3`
  - 返回校验结果

### CaptchaUtils
- `getBufferedImage()`：加载图片（支持网络URL和本地路径）
- `cutByTemplate()`：根据模板切割图片，生成抠图和背景图
- `drawBlock()`：绘制随机形状的抠图模板
- `toBase64()`：将图片转换为 base64 字符串

## 验证流程图

```
用户输入手机号
    ↓
点击"获取验证码"
    ↓
前端调用 getCaptcha() ────→ 后端生成图片并存储 blockX 到 Redis
    ↓                         ↓
显示验证码弹窗              返回 { nonceStr, canvasSrc, blockSrc, blockY }
    ↓
用户拖动滑块到指定位置
    ↓
前端调用 verifyCaptcha() ──→ 后端从 Redis 取出 blockX
    ↓                         ↓
                          校验 |blockX - moveLength| <= 3
    ↓                         ↓
验证成功                   验证通过
    ↓                         ↓
使用 nonceStr 作为 token
    ↓
调用 sendSmsCode() ────→ 后端发送短信验证码
    ↓
显示倒计时，等待用户输入验证码
```

## 安全特性

1. **后端校验**：滑块位置由后端校验，防止前端伪造
2. **Redis缓存**：验证码数据存储在Redis中，15分钟过期
3. **唯一标识**：使用UUID（nonceStr）作为验证码唯一标识
4. **容错机制**：允许3像素的误差范围，提升用户体验
5. **图灵测试**：前端检测拖动轨迹，判断是否为人为操作
6. **时间限制**：10秒内完成验证，防止暴力破解
7. **一次性验证**：验证成功后可使用 nonceStr 发送短信，但不能重复使用

## 测试要点

1. **正常流程**：
   - 验证码图片能否正常加载
   - 滑块能否正常拖动
   - 拖动到正确位置是否验证成功
   - 验证成功后是否触发短信发送

2. **异常流程**：
   - 拖动到错误位置是否验证失败
   - 验证失败后是否可以重试
   - 验证超时（10秒）是否自动失败
   - 网络错误时的提示是否正确

3. **安全测试**：
   - 验证码是否每次都不同
   - 验证码是否15分钟后失效
   - 是否能够绕过验证码直接发送短信

## 注意事项

1. 后端已经准备了两张预设图片，在 `CaptchaUtils` 中配置
2. 验证码组件已支持刷新功能，用户可以点击右上角刷新图标重新获取验证码
3. 验证码弹窗宽度为 380px，适配默认 320px 的画布宽度
4. 组件已重构为 Composition API + TypeScript，具有完整的类型安全

## API 端点总结

| 端点 | 方法 | 说明 | 前端调用 |
|------|------|------|----------|
| `/api/auth-service/captcha` | POST | 获取验证码图片 | `userApi.getCaptcha()` |
| `/api/auth-service/captcha/verify` | POST | 验证滑块位置 | `userApi.verifyCaptcha()` |
| `/api/auth-service/auth/send-sms-code` | POST | 发送短信验证码 | `userStore.sendSmsCode()` |
